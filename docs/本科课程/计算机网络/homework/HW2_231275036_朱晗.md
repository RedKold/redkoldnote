# Chapter 2 Application Layer
### R6
假定你想尽管处理从远程客户到服务器的业务：
我会用 UDP 服务. 因为 UDP 服务是一种无连接的服务，UDP的主要作用是将网络数据流量压缩成数据报的形式，并尽可能快地将数据报传递给目标主机。在这种情况下适合。而 TCP 是有连接的服务，其“四次握手三次挥手”的步骤在此时可能效率太低。
### R7
例如报警应用程序等紧急响应程序，既需要报警信息无缺失，又需要尽快服务（时间敏感）

### R11
这些协议要求以正确顺序接受数据，且不容许数据丢失，TCP 提供此服务，但是 UDP 不行。

### R21
不一定. BitTorrent 协议规定，Alice 会选择能以最高速率向她提供数据的 4 个邻居，Bob 不一定处在其内.

### R22
考虑一个新对等方Alice加入BifTorrent而不拥有任何文件块。没有任何块，因此她没有任何东西可上载，她无法成为任何其他对等方的前4位上载者。那么Alice将怎样得到她的第一个文件块呢？
当一个新对等方 Alice 加入，**追踪器**从当前洪流中随机选择一些对等方作为她的邻近对等方，并从他们那获得第一个文件块。

### R25
重要因素：负载均衡。
各服务器的负载应该大致均衡，才不会出现大量集中流量冲垮服务器的现象.
## P4
a. URL: /cs 453/index. Html   //line 1, GET parameter
b. 1.1
c. 持续连接
d. Host: gaia. Cs. Umass. Edu
e. Mozilla 5.0
	我需要清楚怎么和浏览器客户端交互

## P5
a. 可以（因为返回了 OK）时间为 Tue, 07 Mar 2008
b. 最后被修改：Sat, 19 Dec 2005 18:27:46
c. 3874
d.Keep-Alive 等内容。同意持续连接

## P7
由于假定该对象传输时间为 0，现在计算时间只需要考虑 RTT
由于握手和传输是两个 RTT，只有握手查询没有传输是一个 RTT，所以有：
$$
\text{Time}=2\text{RTT}_{0}+\text{RTT}_{1}+\dots+\text{RTT}_{n}
$$

## P8
a.没有并行 TCP 连接的非持续 HTTP
	这种情况下，我们需要一个个做传输，且每次都要重新连接
	跟 server 握手请求对象是 2 RTT，每一个对象花费 2 RTT
$$
\text{Time}=18\text{RTT}_{0}+\text{RTT}_{1}+\dots+\text{RTT}_{n}
$$
b.
$$
\text{Time}=6\text{RTT}_{0}+\text{RTT}_{1}+\dots+\text{RTT}_{n}
$$
c.
持续不断开，所以每个文件只需要 1 RTT 就可以
总体=连接的 2 RTT + 8\*每个文件的 1 RTT
$$
\text{Time}=10\text{RTT}_{0}+\text{RTT}_{1}+\dots+\text{RTT}_{n}
$$
## P13
考虑经 HTTP/2 发送一个 Web 页面，该页面由一个视频片段和 5 幅图像组成。假定视频片段要传输 2000 帧，每幅图像有 3 帧
a. 无交错：$2000+5\times{3}=2015$ （会等待视频传输结束再传）
b. 有交错：传 1 帧视频，传 1 帧图像：$6$ 帧后完成。

## P20
假定你能够访问所在系的本地 DNS 服务器中的缓存。你能够提出一种方法来粗略的确定在你所在系的用户中最为流行的 Web 服务器（你所在系之外）吗？

我可以查看缓存，找到 DNS 解析最多的 url 所指引到的 Web 服务器，这样就可以粗略确定了。
## P21
如果我访问这个外部 Web 站点加载速度特别快，那么我可能可以确定其几秒前访问过一台 Web 站点。因为 DNS 解析缓存文件仍然存在，域名解析的速度会相当快（0ms）

## P26
a. 可能. 只要有足够的对等群，Bob 就可以不断的接受数据。（Ques：这样是可以突破“一报还一报”吗？）
b. 他可以在每一个主机上运行客户端，让每个主机分别接受 chunks 并合并成单个文件。

## P27
a.  生成混合文件，如果可以让播放者选择任意的视频和音频版本，则需要存储 $N^{2}$ 个文件
b.  如果分别发送，则需要存储 $2N$ 个文件

